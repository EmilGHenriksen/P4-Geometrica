
//--------------MARK UP-----------------------------------------------------------
/*
		the CFG is made with EBNF using this notation:
		? = "0 or 1 times" (aka optional)
		* = "0 or more times"
		+ = "1 or more times"
		| = selection (either left or right side)
		() = group
		'' = literal
		"" = regex

		// = EOL comment
		/*  */ = block comment
*/
//--------------------------------------------------------------------------------


//--------------PROGRAM-----------------------------------------------------------
program   -> (stmt | function)*
//--------------------------------------------------------------------------------


//--------------STATEMENTS--------------------------------------------------------
stmt -> return ';'
	  | declare ';'
	  | assign ';'
	  | select
	  | iterate
	  | '{' stmt* '}'
	  | expr ';'

return -> 'return' expr?
declare    -> type identifier typeModifier? ('IS' expr)?
assign     ->      identifier 'IS' expr
//--------------------------------------------------------------------------------


//--------------SELECTION---------------------------------------------------------
select -> ifSelect
		| switchSelect
ifSelect     -> 'if' '(' expr ')'  '{' stmt* '}' ('else' stmt)?
switchSelect -> 'switch' '(' expr ')'  '{' (definedCase)* defaultCase '}'
definedCase     -> 'case' expr ':' stmt*
defaultCase     -> 'default'    ':' stmt*
//--------------------------------------------------------------------------------
// the last "statement" in ifSelect can also include if statements, so "else if" is possible. The curly brackets in "{" statement "}" should eliminate the dangling else problem


//--------------ITERATION---------------------------------------------------------
iterate ->  foreachIterate
         | loopIterate
         | whileIterate
foreachIterate -> 'foreach' '(' identifier 'in' identifier ')' '{' stmt* '}'
loopIterate    -> 'loop' '(' expr ')' '{' stmt* '}'
whileIterate   -> 'while' '(' expr ')' '{' stmt* '}'
//--------------------------------------------------------------------------------


//--------------CALLS-------------------------------------------------------------
function      -> type identifier '(' parameterDeclareList ')' '{' stmt* '}'
functionCall       -> identifier '(' parameterValueList ')'
parameterDeclareList -> (declare (',' declare)*)?
parameterValueList   -> (expr (',' expr)*)?

methodCall   -> identifier '.' identifier '(' parameterValueList ')'
propertyCall -> identifier '.' identifier
//--------------------------------------------------------------------------------


//--------------EXPRESSIONS-------------------------------------------------------
expr -> literal
	  | identifier
	  | functionCall
	  | methodCall		//example: x.func()
	  | propertyCall    //example: x.name
	  | '(' expr ')'
	  | unaryExpr
	  | binaryExpr
unaryExpr -> unaryOp expr
binaryExpr -> expr binaryOp expr
//--------------------------------------------------------------------------------


//--------------LITERALS----------------------------------------------------------
literal -> intLiteral
		 | floatLiteral
		 | 'PI' //converts to float number for pi
		 | stringLiteral
		 | boolLiteral
		 | angleLiteral
		 | arrayLiteral
		 //the other types have no literals
arrayLiteral ->  '[' (literal (',' literal)*)? ']'
//--------------------------------------------------------------------------------


//--------------TERMINALS / TOKEN SPECIFICATION-----------------------------------
identifier -> "[a-zA-Z_][a-zA-Z_0-9]*"
//--------------------------------------------------------------------------------


//--------------LITERAL TOKENS----------------------------------------------------
intLiteral    -> "0|([1-9][0-9]*)"
floatLiteral  -> "(0|([1-9][0-9]*))[.]([0-9]+)"
stringLiteral -> "[\"][^\n\"]*[\"]"
boolLiteral   -> "TRUE"
			   | "FALSE"
angleLiteral  -> "(0|([1-9][0-9]*))([.][0-9]+)?deg"
			   | "(0|([1-9][0-9]*))([.][0-9]+)?rad" //radians
//--------------------------------------------------------------------------------
// negative numbers are expressions with unary '-'
// int literals are implicitly converted to float (to avoid ambiguity)
// stringLiteral contains anything but literal newline or quote-sign, but notably can contain '\n' (as 2 characters)


//--------------TYPES-------------------------------------------------------------
type -> accessModifier? simpleType
accessModifier -> 'const'
simpleType -> 'void'
			| 'bool'
			| 'int'    //actually longs
			| 'float'  //actually doubles
			| 'string' //char is single-letter string
			//figures below here
			| 'point'
			| 'line'
			| 'triangle'
			| 'square'
			| 'circle'
			| 'angle'
typeModifier -> '[]'*
//--------------------------------------------------------------------------------


//--------------OPERATORS---------------------------------------------------------
unaryOp -> '-'
		 | '+' //e.g. "int a = +30"
		 //boolean unary operators below here
		 | '!'

binaryOp -> '-'
		  | '+' //either add numbers or concatenate strings
		  | '*'
		  | '/' //division
		  | '^' //power
		  | '%' //modulo
		  //any value input, boolean output
		  | '=='
		  | '!='
		  //number input, boolean output
		  | '<'
		  | '>'
		  | '<='
		  | '>='
		  //boolean input and output
		  | 'AND'
		  | 'OR'
//--------------------------------------------------------------------------------
//In terms of precedence: make concrete syntax
