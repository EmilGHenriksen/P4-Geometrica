
//--------------MARK UP-----------------------------------------------------------
/*
		the CFG is made with EBNF using this notation:
		? = "0 or 1 times" (aka optional)
		* = "0 or more times"
		+ = "1 or more times"
		| = selection (either left or right side)
		() = group
		'' = literal
		"" = regex

		// = EOL comment
		/*  */ = block comment
*/
//--------------------------------------------------------------------------------


//--------------PROGRAM-----------------------------------------------------------
program   -> (stmt | function)*
//--------------------------------------------------------------------------------


//--------------STATEMENTS--------------------------------------------------------
stmt -> return ';'
	  | declare ';'
	  | assign ';'
	  | select
	  | iterate
	  | '{' stmtList '}'
	  | expr ';'

stmtList -> stmt*

return -> 'return' expr?
declare    -> AccessModifier? type typeModifier? identifier ('IS' expr)?
assign     ->           identifier typeModAccess  'IS' expr
typeModAccess -> ('[' expr ']')* 
//--------------------------------------------------------------------------------


//--------------SELECTION---------------------------------------------------------
select -> ifSelect
		| switchSelect
ifSelect     -> 'if' '(' expr ')'  '{' stmtList '}' ('else' stmt)?
switchSelect -> 'switch' '(' expr ')'  '{' (definedCase)* defaultCase '}'
definedCase     -> 'case' expr ':' stmtList
defaultCase     -> 'default'    ':' stmtList
//--------------------------------------------------------------------------------
// the last "statement" in ifSelect can also include if statements, so "else if" is possible. The curly brackets in "{" statement "}" should eliminate the dangling else problem


//--------------ITERATION---------------------------------------------------------
iterate ->  foreachIterate
         | loopIterate
         | whileIterate
foreachIterate -> 'foreach' '(' identifier 'in' identifier ')' '{' stmtList '}'
loopIterate    -> 'loop' '(' expr ')' '{' stmtList '}'
whileIterate   -> 'while' '(' expr ')' '{' stmtList '}'
//--------------------------------------------------------------------------------


//--------------CALLS-------------------------------------------------------------
function      -> type typeModifier? identifier '(' parameterDeclareList ')' '{' stmtList '}'
functionCall       ->               identifier '(' parameterValueList ')'
parameterDeclareList -> (declare (',' declare)*)?
parameterValueList   -> (expr (',' expr)*)?

methodCall   -> identifier '.' identifier '(' parameterValueList ')'
propertyCall -> identifier '.' identifier
//--------------------------------------------------------------------------------


//--------------EXPRESSIONS-------------------------------------------------------
expr -> literal
	  | identifier typeModAccess?
	  | functionCall
	  | methodCall		//example: x.func()
	  | propertyCall    //example: x.name
	  | '(' expr ')'
	  | unaryExpr
	  | binaryExpr
unaryExpr -> unaryOp expr
binaryExpr -> expr binaryOp expr
//--------------------------------------------------------------------------------


//--------------LITERALS----------------------------------------------------------
literal -> intLiteral
		 | floatLiteral
		 | 'PI' //converts to float number for pi
		 | stringLiteral
		 | boolLiteral
		 | angleLiteral
		 | arrayLiteral
		 //the other types have no literals
arrayLiteral ->  '[' (literal (',' literal)*)? ']'
//--------------------------------------------------------------------------------


//--------------TERMINALS / TOKEN SPECIFICATION-----------------------------------
identifier -> "[a-zA-Z_][a-zA-Z_0-9]*"
//--------------------------------------------------------------------------------


//--------------LITERAL TOKENS----------------------------------------------------
intLiteral    -> "0|([1-9][0-9]*)"
floatLiteral  -> "(0|([1-9][0-9]*))[.]([0-9]+)"
stringLiteral -> "[\"][^\n\"]*[\"]"
boolLiteral   -> "TRUE"
			   | "FALSE"
angleLiteral  -> "(0|([1-9][0-9]*))([.][0-9]+)?deg"
			   | "(0|([1-9][0-9]*))([.][0-9]+)?rad" //radians
//--------------------------------------------------------------------------------
// negative numbers are expressions with unary '-'
// int literals are implicitly converted to float (to avoid ambiguity)
// stringLiteral contains anything but literal newline or quote-sign, but notably can contain '\n' (as 2 characters)


//--------------TYPES-------------------------------------------------------------
AccessModifier : 'const' ;
type -> 'void'
	  | 'bool'
	  | 'int'    //actually longs
	  | 'float'  //actually doubles
	  | 'string' //char is single-letter string
	  //figures below here
	  | 'point'
	  | 'line'
	  | 'triangle'
	  | 'square'
	  | 'circle'
	  | 'angle'
typeModifier -> '[]'*
//--------------------------------------------------------------------------------


//--------------OPERATORS---------------------------------------------------------
unaryOp -> '-'
		 | '+' //e.g. "int a = +30"
		 //boolean unary operators below here
		 | '!'

binaryOp -> '-'
		  | '+' //either add numbers or concatenate strings
		  | '*'
		  | '/' //division
		  | '^' //power
		  | '%' //modulo
		  //any value input, boolean output
		  | '=='
		  | '!='
		  //number input, boolean output
		  | '<'
		  | '>'
		  | '<='
		  | '>='
		  //boolean input and output
		  | 'AND'
		  | 'OR'
//--------------------------------------------------------------------------------
//In terms of precedence: make concrete syntax
