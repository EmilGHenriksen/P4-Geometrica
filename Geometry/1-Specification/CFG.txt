/*
the CFG is made with EBNF using this notation:
? = "0 or 1 times" (aka optional)
* = "0 or more times"
+ = "1 or more times"
| = selection (either left or right side)
() = group
'' = literal
"" = regex

// = EOL comment
/*  */ = block comment
*/




program   -> (statement | function)*  //maybe add #define option at beginning of file
statement -> return ';'
		   | declaration ';'
		   | assignment ';'
		   | selection
		   | iteration
		   | functionCall ';'
		   | methodCall ';'    //example:  a.move(...)
		   //| class   //maybe add in later version
		   | '{' statement* '}'



//---------statements-----------
return -> 'return' valueEvaluated?

declaration    -> type identifier typeModifier? ('IS' valueEvaluated)?
assignment     ->      identifier  'IS' valueEvaluated
valueEvaluated -> valueLiteral
				| assignment
				| functionCall
				| methodCall
				| identifier
				| propertyCall    //example: x.name
				| expression


selection -> ifSelection
		   | switchSelection
ifSelection     -> 'if' '(' valueEvaluated ')'  '{' statement* '}' ('else' statement)?             //the last "statement" can also include if statements, so "else if" is possible. The curly brackets in "{" statement "}" should eliminate the dangling else problem
switchSelection -> 'switch' '(' valueEvaluated ')'  '{' (definedCase)* defaultCase '}'
definedCase     -> 'case' valueLiteral ':' statement* 'continue;'?
defaultCase     -> 'default'    ':' statement*




iteration -> forIteration
           | foreachIteration
           | loopIteration
           | whileIteration
forIteration     -> 'for' '(' type? assignment ';' valueEvaluated ';' expression ')' '{' statement* '}'
foreachIteration -> 'foreach' '(' identifier 'in' identifier ')' '{' statement* '}'
loopIteration    -> 'loop' '(' valueEvaluated ')' '{' statement* '}'
whileIteration   -> 'while' '(' valueEvaluated ')' '{' statement* '}'


function      -> type identifier '(' parameterDeclareList ')' '{' statement* '}'
functionCall       -> identifier '(' parameterValueList ')'
parameterDeclareList -> (declaration (',' declaration)*)?
parameterValueList   -> (valueEvaluated (',' valueEvaluated)*)?


methodCall   -> identifier '.' identifier '(' parameterValueList ')'   //what about .label, .x and other default parts?


//----------other parts------------
propertyCall -> identifier '.' identifier

expression -> unaryExpression
			| binaryExpression
			| '(' expression ')'
			| expression+
unaryExpression -> unaryOperator valueEvaluated
binaryExpression -> valueEvaluated binaryOperator valueEvaluated //ambiguous?

valueLiteral -> intLiteral
			  | floatLiteral
			  | 'PI' //converts to float number for pi
			  | stringLiteral
			  | boolLiteral
			  | angleLiteral
			  | arrayLiteral
			  //the other types have no literals

arrayLiteral ->  '[' (valueLiteral (',' valueLiteral)*)? ']'





//--------------terminals/token specification-------------
identifier -> "[a-zA-Z_][a-zA-Z_0-9]*"


intLiteral -> "0|([1-9][0-9]*)" //negative numbers are expressions with unary '-'
floatLiteral -> "(0|([1-9][0-9]*))[.]([0-9]+)"
			  //| intLiteral //int literals are implicitly converted to float (to avoid ambiguity)
stringLiteral -> "[\"][^\n]*[\"]" //contains anything but literal newline, but can contain '\n' (2 characters)
boolLiteral -> "[tT]rue"
			 | "[fF]alse"
angleLiteral -> "(0|([1-9][0-9]*))([.]([0-9]+))?deg"
			  | "(0|([1-9][0-9]*))([.]([0-9]+))?rad" //radians


type -> 'void'
	  | 'bool'
	  | 'int'   //actually longs
	  | 'float' //actually doubles
	  | 'string' //char is single-letter string
	  //figure stuff
	  | 'point' 
	  | 'line' 
	  | 'triangle' 
	  | 'square'
	  | 'closedfigure'
	  | 'circle'
	  | 'angle'
typeModifier -> '[]'*


unaryOperator -> '-'
			   | '+' //e.g. "int a = +30"
			   //| cast //(e.g. float to int) maybe add later?
			   //boolean
			   | '!'


	//what about precedence? - make concrete syntax
binaryOperator -> '-'
				| '+' //either add numbers or concatenate strings
				| '*'
				| '/' //division
				| '^' //power
				| '%' //modulo
				//boolean output
				| '=='
				| '!='
				| '<'
				| '>'
				| '<='
				| '>='
				//boolean input and output
				| 'AND'
				| 'OR'
				//more infrequent operators
				| 'XOR'
				| 'XNOR'
				| 'NAND'
				| 'NOR'
